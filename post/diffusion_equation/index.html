<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Exploring the diffusion equation with Python | Zoltán Sylvester</title>
<meta name="keywords" content="geology, modeling, python, sedimentology, erosion, geomorphology, jupyter">
<meta name="description" content="Ever since I became interested in science, I started to have a vague idea that calculus, matrix algebra, partial differential equations, and numerical methods are all fundamental to the physical sciences and engineering and they are linked in some way to each other. The emphasis here is on the word vague; I have to admit that I had no clear, detailed understanding of how these links actually work. It seems like my formal education both in math and physics stopped just short of where everything would have nicely come together. Papers that are really important in geomorphology, sedimentology or stratigraphy seemed impossible to read as soon as they started assuming that I knew quite a bit about convective acceleration, numerical schemes, boundary conditions, and Cholesky factorization. Because I didn’t.">
<meta name="author" content="Zoltán Sylvester">
<link rel="canonical" href="https://zsylvester.github.io/post/diffusion_equation/">
<link crossorigin="anonymous" href="https://zsylvester.github.io/assets/css/stylesheet.19586efa8311b6fd3d8d2c4fa1b5a9fe1614b75098dcf78e7bb3e0c3ceaf056e.css" integrity="sha256-GVhu&#43;oMRtv09jSxPobWp/hYUt1CY3PeOe7Pgw86vBW4=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zsylvester.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zsylvester.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zsylvester.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zsylvester.github.io/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://zsylvester.github.io/post/diffusion_equation/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://zsylvester.github.io/post/diffusion_equation/">
  <meta property="og:site_name" content="Zoltán Sylvester">
  <meta property="og:title" content="Exploring the diffusion equation with Python">
  <meta property="og:description" content="Ever since I became interested in science, I started to have a vague idea that calculus, matrix algebra, partial differential equations, and numerical methods are all fundamental to the physical sciences and engineering and they are linked in some way to each other. The emphasis here is on the word vague; I have to admit that I had no clear, detailed understanding of how these links actually work. It seems like my formal education both in math and physics stopped just short of where everything would have nicely come together. Papers that are really important in geomorphology, sedimentology or stratigraphy seemed impossible to read as soon as they started assuming that I knew quite a bit about convective acceleration, numerical schemes, boundary conditions, and Cholesky factorization. Because I didn’t.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2015-02-06T00:00:00+00:00">
    <meta property="article:modified_time" content="2015-02-06T00:00:00+00:00">
    <meta property="article:tag" content="Geology">
    <meta property="article:tag" content="Modeling">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="Sedimentology">
    <meta property="article:tag" content="Erosion">
    <meta property="article:tag" content="Geomorphology">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Exploring the diffusion equation with Python">
<meta name="twitter:description" content="Ever since I became interested in science, I started to have a vague idea that calculus, matrix algebra, partial differential equations, and numerical methods are all fundamental to the physical sciences and engineering and they are linked in some way to each other. The emphasis here is on the word vague; I have to admit that I had no clear, detailed understanding of how these links actually work. It seems like my formal education both in math and physics stopped just short of where everything would have nicely come together. Papers that are really important in geomorphology, sedimentology or stratigraphy seemed impossible to read as soon as they started assuming that I knew quite a bit about convective acceleration, numerical schemes, boundary conditions, and Cholesky factorization. Because I didn’t.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://zsylvester.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Exploring the diffusion equation with Python",
      "item": "https://zsylvester.github.io/post/diffusion_equation/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Exploring the diffusion equation with Python",
  "name": "Exploring the diffusion equation with Python",
  "description": "Ever since I became interested in science, I started to have a vague idea that calculus, matrix algebra, partial differential equations, and numerical methods are all fundamental to the physical sciences and engineering and they are linked in some way to each other. The emphasis here is on the word vague; I have to admit that I had no clear, detailed understanding of how these links actually work. It seems like my formal education both in math and physics stopped just short of where everything would have nicely come together. Papers that are really important in geomorphology, sedimentology or stratigraphy seemed impossible to read as soon as they started assuming that I knew quite a bit about convective acceleration, numerical schemes, boundary conditions, and Cholesky factorization. Because I didn’t.\n",
  "keywords": [
    "geology", "modeling", "python", "sedimentology", "erosion", "geomorphology", "jupyter"
  ],
  "articleBody": "Ever since I became interested in science, I started to have a vague idea that calculus, matrix algebra, partial differential equations, and numerical methods are all fundamental to the physical sciences and engineering and they are linked in some way to each other. The emphasis here is on the word vague; I have to admit that I had no clear, detailed understanding of how these links actually work. It seems like my formal education both in math and physics stopped just short of where everything would have nicely come together. Papers that are really important in geomorphology, sedimentology or stratigraphy seemed impossible to read as soon as they started assuming that I knew quite a bit about convective acceleration, numerical schemes, boundary conditions, and Cholesky factorization. Because I didn’t.\nSo I have decided a few months ago that I had to do something about this. This blog post documents the initial – and admittedly difficult – steps of my learning; the purpose is to go through the process of discretizing a partial differential equation, setting up a numerical scheme, and solving the resulting system of equations in Python and IPython notebook. I am learning this as I am doing it, so it may seem pedestrian and slow-moving to a lot of people but I am sure there are others who will find it useful. Most of what follows, except the Python code and the bit on fault scarps, is based on and inspired by Slingerland and Kump (2011): Mathematical Modeling of Earth’s Dynamical Systems (strongly recommended). You can view and download the IPython Notebook version of this post from Github.\nEstimating the derivatives in the diffusion equation using the Taylor expansion This is the one-dimensional diffusion equation:\n$$\\frac{\\partial T}{\\partial t} - D\\frac{\\partial^2 T}{\\partial x^2} = 0$$\nThe Taylor expansion of value of a function u at a point $\\Delta x$ ahead of the point x where the function is known can be written as:\n$$ u(x+\\Delta x) = u(x) + \\Delta x \\frac{\\partial u}{\\partial x} + \\frac{\\Delta x^2}{2} \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\Delta x^3}{6} \\frac{\\partial^3 u}{\\partial x^3} + O(\\Delta x^4) $$\nTaylor expansion of value of the function $u$ at a point one space step behind:\n$$ u(x-\\Delta x) = u(x) - \\Delta x \\frac{\\partial u}{\\partial x} + \\frac{\\Delta x^2}{2} \\frac{\\partial^2 u}{\\partial x^2} - \\frac{\\Delta x^3}{6} \\frac{\\partial^3 u}{\\partial x^3} + O(\\Delta x^4) $$\nSolving the first Taylor expansion above for $\\frac{\\partial u}{\\partial x}$ and dropping all higher-order terms yields the forward difference operator:\n$$ \\frac{\\partial u}{\\partial x} = \\frac{u(x+\\Delta x)-u(x)}{\\Delta x} + O(\\Delta x) $$\nSimilarly, the second equation yields the backward difference operator:\n$$ \\frac{\\partial u}{\\partial x} = \\frac{u(x)-u(x-\\Delta x)}{\\Delta x} + O(\\Delta x) $$\nSubtracting the second equation from the first one gives the centered difference operator:\n$$ \\frac{\\partial u}{\\partial x} = \\frac{u(x+\\Delta x)-u(x-\\Delta x)}{2\\Delta x} + O(\\Delta x^2) $$\nThe centered difference operator is more accurate than the other two.\nFinally, if the two Taylor expansions are added, we get an estimate of the second order partial derivative:\n$$ \\frac{\\partial^2 u}{\\partial x^2} = \\frac{u(x+\\Delta x)-2u(x)+u(x-\\Delta x)}{\\Delta x^2} + O(\\Delta x^2) $$\nNext we use the forward difference operator to estimate the first term in the diffusion equation:\n$$ \\frac{\\partial T}{\\partial t} = \\frac{T(t+\\Delta t)-T(t)}{\\Delta t} $$\nThe second term is expressed using the estimation of the second order partial derivative:\n$$ \\frac{\\partial^2 T}{\\partial x^2} = \\frac{T(x+\\Delta x)-2T(x)+T(x-\\Delta x)}{\\Delta x^2} $$\nNow the diffusion equation can be written as\n$$ \\frac{T(t+\\Delta t)-T(t)}{\\Delta t} - D \\frac{T(x+\\Delta x)-2T(x)+T(x-\\Delta x)}{\\Delta x^2} = 0 $$\nThis is equivalent to\n$$ T(t+\\Delta t) - T(t) - \\frac{D\\Delta t}{\\Delta x^2}(T(x+\\Delta x)-2T(x)+T(x-\\Delta x)) = 0 $$\nThe expression $ D\\frac{\\Delta t}{\\Delta x^2} $ is called the diffusion number, denoted here with $s$:\n$$ s = D\\frac{\\Delta t}{\\Delta x^2} $$\nFTCS explicit scheme and analytic solution If we use $n$ to refer to indices in time and $j$ to refer to indices in space, the above equation can be written as\n$$ T[n+1,j] = T[n,j] + s(T[n,j+1]-2T[n,j]+T[n,j-1]) $$\nThis is called a forward-in-time, centered-in-space (FTCS) scheme. Its ‘footprint’ looks like this:\nimport numpy as np import matplotlib.pyplot as plt %matplotlib inline %config InlineBackend.figure_format = 'svg' # display plots in SVG format fig = plt.figure(figsize=(6,3)) plt.plot([0,2],[0,0],'k') plt.plot([1,1],[0,1],'k') plt.plot([0,1,2,1],[0,0,0,1],'ko',markersize=10) plt.text(1.1,0.1,'T[n,j]') plt.text(0.1,0.1,'T[n,j-1]') plt.text(1.1,1.1,'T[n+1,j]') plt.text(2.1,0.1,'T[n,j+1]') plt.xlabel('space') plt.ylabel('time') plt.axis('equal') plt.yticks([0.0,1.0],[]) plt.xticks([0.0,1.0],[]) plt.title('FTCS explicit scheme',fontsize=12) plt.axis([-0.5,2.5,-0.5,1.5]); Now we are ready to write the code that is the solution for exercise 2 in Chapter 2 of Slingerland and Kump (2011). This is an example where the one-dimensional diffusion equation is applied to viscous flow of a Newtonian fluid adjacent to a solid wall. If the wall starts moving with a velocity of 10 m/s, and the flow is assumed to be laminar, the velocity profile of the fluid is described by the equation\n$$ \\frac{\\partial V}{\\partial t} - \\nu \\frac{\\partial^2 V}{\\partial y^2} = 0 $$\nwhere $\\nu$ is the kinematic viscosity of the fluid. We want to figure out how the velocity will change through time as a function of distance from the wall. [Note that I have changed the original 40 m/s to 10 m/s – the former seems like an unnaturally large velocity to me].\nWe can compare the numerical results with the analytic solution, which is known for this problem:\n$$ V = V_0 \\Big( \\sum\\limits_0^\\infty erfc(2n\\eta_1+\\eta) - \\sum\\limits_0^\\infty erfc(2(n+1)\\eta_1+\\eta) \\Big) $$\nwhere\n$$ \\eta_1 = \\frac{h}{2\\sqrt{\\nu t}} $$\nand\n$$ \\eta = \\frac{y}{2\\sqrt{\\nu t}} $$\ndt = 0.0005 # grid size for time (s) dy = 0.0005 # grid size for space (m) viscosity = 2*10**(-4) # kinematic viscosity of oil (m2/s) y_max = 0.04 # in m t_max = 1 # total time in s V0 = 10 # velocity in m/s # function to calculate velocity profiles based on a finite difference approximation to the 1D diffusion equation and the # FTCS (forward-in-time, centered-in-space) scheme: def diffusion_FTCS(dt,dy,t_max,y_max,viscosity,V0): # diffusion number (has to be less than 0.5 for the solution to be stable): s = viscosity*dt/dy**2 y = np.arange(0,y_max+dy,dy) t = np.arange(0,t_max+dt,dt) r = len(t) c = len(y) V = np.zeros([r,c]) V[:,0] = V0 for n in range(0,r-1): # time for j in range(1,c-1): # space V[n+1,j] = V[n,j] + s*(V[n,j-1] - 2*V[n,j] + V[n,j+1]) return y,V,r,s # note that this can be written without the for-loop in space, but it is easier to read it this way from scipy.special import erfc # function to calculate velocity profiles using the analytic solution: def diffusion_analytic(t,h,V0,dy,viscosity): y = np.arange(0,h+dy,dy) eta1 = h/(2*(t*viscosity)**0.5) eta = y/(2*(t*viscosity)**0.5) sum1 = 0 sum2 = 0 for n in range(0,1000): sum1 = sum1 + erfc(2*n*eta1+eta) sum2 = sum2 + erfc(2*(n+1)*eta1-eta) V_analytic = V0*(sum1-sum2) return V_analytic y,V,r,s = diffusion_FTCS(dt,dy,t_max,y_max,viscosity,V0) # plotting: plt.figure(figsize=(7,5)) plot_times = np.arange(0.2,1.0,0.1) for t in plot_times: plt.plot(y,V[t/dt,:],'Gray',label='numerical') V_analytic = diffusion_analytic(t,0.04,10,dy,viscosity) plt.plot(y,V_analytic,'ok',label='analytic',markersize=3) if t==0.2: plt.legend(fontsize=12) plt.xlabel('distance from wall (m)',fontsize=12) plt.ylabel('velocity (m/s)',fontsize=12) plt.axis([0,y_max,0,V0]) plt.title('comparison between explicit numerical \\n(FTCS scheme) and analytic solutions'); The dots (analytic solution) overlap pretty well with the lines (numerical solution). However, this would not be the case if we changed the discretization so that the diffusion number was larger. Let’s look at the stability of the FTCS numerical scheme, by computing the solution with different diffusion numbers. It turns out that the diffusion number $s$ has to be less than 0.5 for the FTCS scheme to remain stable. What follows is a reproduction of Figure 2.7 in Slingerland and Kump (2011):\ndt = 0.0005 # grid size for time (m) dy = 0.0005 # grid size for space (s) y,V,r,s = diffusion_FTCS(dt,dy,t_max,y_max,viscosity,V0) V_analytic = diffusion_analytic(0.5,0.04,V0,dy,viscosity) plt.figure(figsize=(7,5)) plt.plot(y,V_analytic-V[int(0.5/dt)],'--k',label='small s') dy = 0.0010 dt = 0.00254 y,V,r,s = diffusion_FTCS(dt,dy,t_max,y_max,viscosity,V0) V_analytic = diffusion_analytic(0.5,0.04,V0,dy,viscosity) V_numeric = V[int(r/2-1),:] plt.plot(y,V_analytic-V_numeric,'k',label='large s') plt.xlabel('distance from wall (m)',fontsize=12) plt.ylabel('velocity difference (m/s)',fontsize=12) plt.title('difference between numerical and analytic \\n solutions for different \\'s\\' values',fontsize=14) plt.axis([0,y_max,-4,4]) plt.legend(); Laasonen implicit scheme plt.figure(figsize=(6,3)) plt.plot([0,2],[1,1],'k') plt.plot([1,1],[0,1],'k') plt.plot([0,1,2,1],[1,1,1,0],'ko',markersize=10) plt.text(1.1,0.1,'T[n,j]') plt.text(0.1,1.1,'T[n+1,j-1]') plt.text(1.1,1.1,'T[n+1,j]') plt.text(2.1,1.1,'T[n+1,j+1]') plt.xlabel('space') plt.ylabel('time') plt.axis('equal') plt.yticks([0.0,1.0],[]) plt.xticks([0.0,1.0],[]) plt.title('Laasonen scheme',fontsize=12) plt.axis([-0.5,2.5,-0.5,1.5]); Instead of estimating the velocity at time step $n+1$ with the curvature calculated at time step $n$, as it is done in the FTCS explicit scheme, we can also estimate the curvature at time step $n+1$, using the velocity change from time step $n$ to time step $n+1$:\n$$ s\\big(T(x+\\Delta x)-2T(x)+T(x-\\Delta x)\\big) = T(t+\\Delta t)-T(t) $$\nWritten in matrix notation, this is equiavlent to\n$$ s\\big(T[n+1,j+1]-2T[n+1,j]+T[n+1,j-1]\\big) = T[n+1,j]-T[n,j] $$\nAfter some reshuffling we get\n$$ -sT[n+1,j+1] + (1+2s)T[n+1,j] - sT[n+1,j-1] = T[n,j] $$\nThis is the Laasonen fully implicit scheme. Unlike the FTCS scheme, the Laasonen scheme is unconditionally stable. Let’s try to write some Python code that implements this scheme. First it is useful for me to go through the logic of constructing the system of equations that needs to be solved. Let’s consider a grid that only consists of 5 nodes in space and we are going to estimate the values of $T$ at the locations marked by the red dots in the figure below. Black dots mark the locations where we already know the values of $T$ (from the initial and boundary conditions).\nplt.figure(figsize=(6,3)) plt.plot([0,4,4,0],[0,0,1,1],'k') for i in range(0,4): plt.plot([i,i],[0,1],'k') plt.plot([0,1,2,3,4,0,4],[0,0,0,0,0,1,1],'ko',markersize=10) plt.plot([1,2,3],[1,1,1],'ro',markersize=10) for i in range(0,5): plt.text(i+0.1,0.1,'T[0,'+str(i)+']') plt.text(i+0.1,1.1,'T[1,'+str(i)+']') plt.xlabel('space') plt.ylabel('time') plt.axis('equal') plt.yticks([0.0,1.0],['0','1']) plt.title('first two time steps on a 1D grid of five points',fontsize=12) plt.axis([-0.5,4.8,-0.5,1.5]); First we write the equations using the Laasonen scheme centered on the three points of unknown velocity (or temperature) – these are the red dots in the figure above:\nIt may seem like we have five unknowns and only three equations but $T[1,0]$ and $T[1,4]$ are on the boundaries and they are known. Let’s rearrange the equation system so that the left hand side has ony the unknowns:\nIn matrix form this is equivalent to\nThis of course can be extended to larger dimensions than shown here. Now we are ready to write the code for the Laasonen scheme. One important difference relative to what I did in the explicit scheme example is that in this case we only keep the last two versions of the velocity distribution in memory, as opposed to preallocating the full array of $nt \\times ny$ size as we did before. This difference is not a significant time saver for simple problems like this but once you start dealing with more complicated tasks and code it is not possible and/or practical to keep the results of all time steps in memory.\nfrom scipy.sparse import diags def diffusion_Laasonen(dt,dy,t_max,y_max,viscosity,V0,V1): s = viscosity*dt/dy**2 # diffusion number y = np.arange(0,y_max+dy,dy) t = np.arange(0,t_max+dt,dt) nt = len(t) # number of time steps ny = len(y) # number of dy steps V = np.zeros((ny,)) # initial condition V[0] = V0 # boundary condition on left side V[-1] = V1 # boundary condition on right side A = diags([-s, 1+2*s, -s], [-1, 0, 1], shape=(ny-2, ny-2)).toarray() # create coefficient matrix for n in range(nt): # time is going from second time step to last Vn = V #.copy() B = Vn[1:-1] # create matrix of knowns on the RHS of the equation B[0] = B[0]+s*V0 B[-1] = B[-1]+s*V1 V[1:-1] = np.linalg.solve(A,B) # solve the equation using numpy return y,t,V,s Because this is a stable scheme, it is possible to get reasonable solutions with relatively large time steps (which was not possible with the FTCS scheme):\ndt = 0.01 # grid size for time (s) dy = 0.0005 # grid size for space (m) viscosity = 2*10**(-4) # kinematic viscosity of oil (m2/s) y_max = 0.04 # in m V0 = 10.0 # velocity in m/s V1 = 0.0 # velocity in m/s plt.figure(figsize=(7,5)) for time in np.linspace(0,1.0,10): y,t,V,s = diffusion_Laasonen(dt,dy,time,y_max,viscosity,V0,V1) plt.plot(y,V,'k') plt.xlabel('distance from wall (m)',fontsize=12) plt.ylabel('velocity (m/s)',fontsize=12) plt.axis([0,y_max,0,V0]) plt.title('Laasonen implicit scheme',fontsize=14); Just for fun, let’s see what happens if we set in motion the right side of the domain as well; that is, set $V_1$ to a non-zero value:\ndt = 0.01 # grid size for time (s) dy = 0.0005 # grid size for space (m) viscosity = 2*10**(-4) # kinematic viscosity of oil (m2/s) y_max = 0.04 # in m V0 = 10.0 # velocity in m/s V1 = 5.0 # velocity in m/s plt.figure(figsize=(7,5)) for time in np.linspace(0,1.0,10): y,t,V,s = diffusion_Laasonen(dt,dy,time,y_max,viscosity,V0,V1) plt.plot(y,V,'k') plt.xlabel('distance from wall (m)',fontsize=12) plt.ylabel('velocity (m/s)',fontsize=12) plt.axis([0,y_max,0,V0]) plt.title('Laasonen implicit scheme',fontsize=14); Crank-Nicolson scheme The Crank-Nicholson scheme is based on the idea that the forward-in-time approximation of the time derivative is estimating the derivative at the halfway point between times $n$ and $n+1$, therefore the curvature of space should be estimated there as well. The ‘footprint’ of the scheme looks like this:\nplt.figure(figsize=(6,3)) plt.plot([0,2],[0,0],'k') plt.plot([0,2],[1,1],'k') plt.plot([1,1],[0,1],'k') plt.plot([0,1,2,0,1,2],[0,0,0,1,1,1],'ko',markersize=10) plt.text(0.1,0.1,'T[n,j-1]') plt.text(1.1,0.1,'T[n,j]') plt.text(2.1,0.1,'T[n,j+1]') plt.text(0.1,1.1,'T[n+1,j-1]') plt.text(1.1,1.1,'T[n+1,j]') plt.text(2.1,1.1,'T[n+1,j+1]') plt.xlabel('space') plt.ylabel('time') plt.axis('equal') plt.yticks([0.0,1.0],[]) plt.xticks([0.0,1.0],[]) plt.title('Crank-Nicolson scheme',fontsize=12) plt.axis([-0.5,2.5,-0.5,1.5]); The curvature at the halfway point can be estimated through averaging the curvatures that are calculated at $n$ and $n+1$:\n$$ 0.5s\\big(T[n+1,j+1]-2T[n+1,j]+T[n+1,j-1]\\big) + 0.5s\\big(T[n,j+1]-2T[n,j]+T[n,j-1]\\big) = T[n+1,j]-T[n,j] $$\nThis can be rearranged so that terms at $n+1$ are on the left hand side:\n$$ -0.5sT[n+1,j-1]+(1+s)T[n+1,j]-0.5sT[n+1,j+1] = 0.5sT[n,j-1]+(1-s)T[n,j]+0.5sT[n,j+1] $$\nJust like we did for the Laasonen scheme, we can write the equations for the first two time steps:\nWriting this in matrix form, with all the unknowns on the LHS:\nNow we can write the code for the Crank-Nicolson scheme. We will use a new input parameter called $ntout$ that determines how many time steps we want to write out to memory. This way you don’t have to re-run the code if you want to plot multiple time steps.\ndef diffusion_Crank_Nicolson(dy,ny,dt,nt,D,V,ntout): Vout = [] # list for storing V arrays at certain time steps V0 = V[0] # boundary condition on left side V1 = V[-1] # boundary condition on right side s = D*dt/dy**2 # diffusion number A = diags([-0.5*s, 1+s, -0.5*s], [-1, 0, 1], shape=(ny-2, ny-2)).toarray() # create coefficient matrix B1 = diags([0.5*s, 1-s, 0.5*s],[-1, 0, 1], shape=(ny-2, ny-2)).toarray() for n in range(1,nt): # time is going from second time step to last Vn = V B = np.dot(Vn[1:-1],B1) B[0] = B[0]+0.5*s*(V0+V0) B[-1] = B[-1]+0.5*s*(V1+V1) V[1:-1] = np.linalg.solve(A,B) if n % int(nt/float(ntout)) == 0 or n==nt-1: Vout.append(V.copy()) # numpy arrays are mutable, so we need to write out a copy of V, not V itself return Vout,s dt = 0.001 # grid size for time (s) dy = 0.001 # grid size for space (m) viscosity = 2*10**(-4) # kinematic viscosity of oil (m2/s) y_max = 0.04 # in m y = np.arange(0,y_max+dy,dy) ny = len(y) nt = 1000 plt.figure(figsize=(7,5)) V = np.zeros((ny,)) # initial condition V[0] = 10 Vout,s = diffusion_Crank_Nicolson(dy,ny,dt,nt,viscosity,V,10) for V in Vout: plt.plot(y,V,'k') plt.xlabel('distance from wall (m)',fontsize=12) plt.ylabel('velocity (m/s)',fontsize=12) plt.axis([0,y_max,0,V[0]]) plt.title('Crank-Nicolson scheme',fontsize=14); Fault scarp diffusion So far we have been using a somewhat artificial (but simple) example to explore numerical methods that can be used to solve the diffusion equation. Next we look at a geomorphologic application: the evolution of a fault scarp through time. Although the idea that convex hillslopes are the result of diffusive processes go back to G. K. Gilbert, it was Culling (1960, in the paper Analytical Theory of Erosion) who first applied the mathematics of the heat equation - that was already well known to physicists at that time - to geomorphology.\nHere I used the Crank-Nicolson scheme to model a fault scarp with a vertical offset of 10 m. To compare the numerical results with the analytical solution (which comes from Culling, 1960), I created a function that was written using a Python package for symbolic math called sympy. One of the advantages of sympy is that you can quickly display equations in $\\LaTeX$.\nimport sympy from sympy import init_printing init_printing(use_latex=True) x, t, Y1, a, K = sympy.symbols('x t Y1 a K') Y = (1/2.0)*Y1*(sympy.erf((a-x)/(2*sympy.sqrt(K*t))) + sympy.erf((a+x)/(2*sympy.sqrt(K*t)))) Y The variables in this equation are $x$ - horizontal coordinates, $t$ - time, $a$ - value of $x$ where fault is located, $K$ - diffusion coefficient, $Y_1$ - height of fault scarp.\nfrom sympy.utilities.lambdify import lambdify f = lambdify((x, t, Y1, a, K), Y, modules=['numpy', 'sympy']) # function for analytic solution dt = 2.5 # time step (years) dy = 0.1 # grid size for space (m) D = 50E-4 # diffusion coefficient in m2/yr - e.g., Fernandes and Dietrich, 1997 h = 10 # height of fault scarp in m y_max = 20 # length of domain in m t_max = 500 # total time in years y = np.arange(0,y_max+dy,dy) ny = len(y) nt = int(t_max/dt) V = np.zeros((ny,)) # initial condition V[:round(ny/2.0)] = h # initial condition Vout,s = diffusion_Crank_Nicolson(dy,ny,dt,nt,D,V,20) plt.figure(figsize=(10,5.2)) for V in Vout: plt.plot(y,V,'gray') plt.xlabel('distance (m)',fontsize=12) plt.ylabel('height (m)',fontsize=12) plt.axis([0,y_max,0,10]) plt.title('fault scarp diffusion',fontsize=14); plt.plot(y,np.asarray([f(x0, t_max, h, y_max/2.0, D) for x0 in y]),'r--',linewidth=2); The numerical and analytic solutions (dashed red line) are very similar in this case (total time = 500 years). Let’s see what happens if we let the fault scarp evolve for a longer time.\ndt = 2.5 # time step (years) dy = 0.1 # grid size for space (m) D = 50E-4 # diffusion coefficient in m2/yr - e.g., Fernandes and Dietrich, 1997 h = 10 # height of fault scarp in m y_max = 20 # length of domain in m t_max = 5000 # total time in years y = np.arange(0,y_max+dy,dy) ny = len(y) nt = int(t_max/dt) V = np.zeros((ny,)) # initial condition V[:round(ny/2.0)] = h # initial condition Vout,s = diffusion_Crank_Nicolson(dy,ny,dt,nt,D,V,20) plt.figure(figsize=(10,5.2)) for V in Vout: plt.plot(y,V,'gray') plt.xlabel('distance (m)',fontsize=12) plt.ylabel('height (m)',fontsize=12) plt.axis([0,y_max,0,10]) plt.title('fault scarp diffusion',fontsize=14); plt.plot(y,np.asarray([f(x0, t_max, h, y_max/2.0, D) for x0 in y]),'r--',linewidth=2); This doesn’t look very good, does it? The reason for the significant mismatch between the numerical and analytic solutions is the fixed nature of the boundary conditions: we keep the elevation at 10 m on the left side and at 0 m on the right side of the domain. There are two ways of getting a correct numerical solution: we either impose boundary conditions that approximate what the system is supposed to do if the elevations were not fixed; or we extend the space domain so that the boundary conditions can be kept fixed throughout the time of interest. Let’s do the latter; all the other parameters are the same as above.\ndt = 2.5 # time step (years) dy = 0.1 # grid size for space (m) D = 50E-4 # diffusion coefficient in m2/yr - e.g., Fernandes and Dietrich, 1997 h = 10 # height of fault scarp in m y_max = 40 # length of domain in m t_max = 5000 # total time in years y = np.arange(0,y_max+dy,dy) ny = len(y) nt = int(t_max/dt) V = np.zeros((ny,)) # initial condition V[:round(ny/2.0)] = h # initial condition Vout,s = diffusion_Crank_Nicolson(dy,ny,dt,nt,D,V,20) plt.figure(figsize=(10,5.2)) for V in Vout: plt.plot(y,V,'gray') plt.xlabel('distance (m)',fontsize=12) plt.ylabel('height (m)',fontsize=12) plt.axis([0,y_max,0,10]) plt.title('fault scarp diffusion',fontsize=14); plt.plot(y,np.asarray([f(x0, t_max, h, y_max/2.0, D) for x0 in y]),'r--',linewidth=2); Now we have a much better result. The vertical dashed lines show the extent of the domain in the previous experiment. We have also gained some insight into choosing boundary conditions and setting up the model domain. It is not uncommon that setting up the initial and boundary conditions is the most time-consuming and difficult part of running a numerical model.\nFurther reading R. Slingerland and L. Kump (2011) Mathematical Modeling of Earth’s Dynamical Systems\nW. E. H. Culling (1960) Analytical Theory of Erosion\nL. Barba (2013) 12 steps to Navier-Stokes - an excellent introduction to computational fluid dynamics that uses IPython notebooks\nI have blogged before about the geosciency aspects of the diffusion equation over here.\n",
  "wordCount" : "3207",
  "inLanguage": "en",
  "datePublished": "2015-02-06T00:00:00Z",
  "dateModified": "2015-02-06T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Zoltán Sylvester"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zsylvester.github.io/post/diffusion_equation/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Zoltán Sylvester",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zsylvester.github.io/favicon.ico"
    }
  }
}
</script>



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: "\\begin{equation}", right: "\\end{equation}", display: true},
            {left: "\\begin{equation*}", right: "\\end{equation*}", display: true},
            {left: "\\begin{align}", right: "\\end{align}", display: true},
            {left: "\\begin{align*}", right: "\\end{align*}", display: true},
            {left: "\\begin{alignat}", right: "\\end{alignat}", display: true},
            {left: "\\begin{gather}", right: "\\end{gather}", display: true},
            {left: "\\begin{CD}", right: "\\end{CD}", display: true},
          ],
          throwOnError : false
        });
    });
</script>
 


</head>

<body class="" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zsylvester.github.io/" accesskey="h" title="Zoltán Sylvester">
                <img src="https://zsylvester.github.io/favicon.ico" alt="" aria-label="logo"
                    height="18"
                    width="18">Zoltán Sylvester</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zsylvester.github.io/research/" title="Research">
                    <span>Research</span>
                </a>
            </li>
            <li>
                <a href="https://zsylvester.github.io/papers/" title="Publications">
                    <span>Publications</span>
                </a>
            </li>
            <li>
                <a href="https://zsylvester.github.io/post/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Exploring the diffusion equation with Python
    </h1>
    <div class="post-meta"><span title='2015-02-06 00:00:00 +0000 UTC'>February 6, 2015</span>&nbsp;&middot;&nbsp;Zoltán Sylvester

</div>
  </header> 
  <div class="post-content"><p>Ever since I became interested in science, I started to have a vague idea that calculus, matrix algebra, partial differential equations, and numerical methods are all fundamental to the physical sciences and engineering and they are linked in some way to each other. The emphasis here is on the word vague; I have to admit that I had no clear, detailed understanding of how these links actually work. It seems like my formal education both in math and physics stopped just short of where everything would have nicely come together. Papers that are really important in geomorphology, sedimentology or stratigraphy seemed impossible to read as soon as they started assuming that I knew quite a bit about convective acceleration, numerical schemes, boundary conditions, and Cholesky factorization. Because I didn’t.</p>
<p>So I have decided a few months ago that I had to do something about this. This blog post documents the initial – and admittedly difficult – steps of my learning; the purpose is to go through the process of discretizing a partial differential equation, setting up a numerical scheme, and solving the resulting system of equations in Python and IPython notebook. I am learning this as I am doing it, so it may seem pedestrian and slow-moving to a lot of people but I am sure there are others who will find it useful. Most of what follows, except the Python code and the bit on fault scarps, is based on and inspired by Slingerland and Kump (2011): <a href="http://www.amazon.com/dp/0691145148/ref=cm_sw_r_tw_dp_iG3Wub0YJKYJK" target="_blank">Mathematical Modeling of Earth’s Dynamical Systems</a> (strongly recommended). You can view and download the <a href="https://github.com/zsylvester/notebooks/blob/master/diffusion_equation.ipynb" target="_blank">IPython Notebook version of this post</a> from Github.</p>
<h2 id="estimating-the-derivatives-in-the-diffusion-equation-using-the-taylor-expansion">Estimating the derivatives in the diffusion equation using the Taylor expansion</h2>
<p>This is the one-dimensional diffusion equation:</p>
<p>$$\frac{\partial T}{\partial t} - D\frac{\partial^2 T}{\partial x^2} = 0$$</p>
<p>The Taylor expansion of value of a function u at a point $\Delta x$  ahead of the point x where the function is known can be written as:</p>
<p>$$ u(x+\Delta x) = u(x) + \Delta x \frac{\partial u}{\partial x} + \frac{\Delta x^2}{2} \frac{\partial^2 u}{\partial x^2} + \frac{\Delta x^3}{6} \frac{\partial^3 u}{\partial x^3} + O(\Delta x^4) $$</p>
<p>Taylor expansion of value of the function $u$ at a point one space step behind:</p>
<p>$$ u(x-\Delta x) = u(x) - \Delta x \frac{\partial u}{\partial x} + \frac{\Delta x^2}{2} \frac{\partial^2 u}{\partial x^2} - \frac{\Delta x^3}{6} \frac{\partial^3 u}{\partial x^3} + O(\Delta x^4) $$</p>
<p>Solving the first Taylor expansion above for $\frac{\partial u}{\partial x}$ and dropping all higher-order terms yields the forward difference operator:</p>
<p>$$ \frac{\partial u}{\partial x} = \frac{u(x+\Delta x)-u(x)}{\Delta x} + O(\Delta x) $$</p>
<p>Similarly, the second equation yields the backward difference operator:</p>
<p>$$ \frac{\partial u}{\partial x} = \frac{u(x)-u(x-\Delta x)}{\Delta x} + O(\Delta x) $$</p>
<p>Subtracting the second equation from the first one gives the centered difference operator:</p>
<p>$$ \frac{\partial u}{\partial x} = \frac{u(x+\Delta x)-u(x-\Delta x)}{2\Delta x} + O(\Delta x^2) $$</p>
<p>The centered difference operator is more accurate than the other two.</p>
<p>Finally, if the two Taylor expansions are added, we get an estimate of the second order partial derivative:</p>
<p>$$ \frac{\partial^2 u}{\partial x^2} = \frac{u(x+\Delta x)-2u(x)+u(x-\Delta x)}{\Delta x^2} + O(\Delta x^2) $$</p>
<p>Next we use the forward difference operator to estimate the first term in the diffusion equation:</p>
<p>$$ \frac{\partial T}{\partial t} = \frac{T(t+\Delta t)-T(t)}{\Delta t} $$</p>
<p>The second term is expressed using the estimation of the second order partial derivative:</p>
<p>$$ \frac{\partial^2 T}{\partial x^2} = \frac{T(x+\Delta x)-2T(x)+T(x-\Delta x)}{\Delta x^2} $$</p>
<p>Now the diffusion equation can be written as</p>
<p>$$ \frac{T(t+\Delta t)-T(t)}{\Delta t} - D \frac{T(x+\Delta x)-2T(x)+T(x-\Delta x)}{\Delta x^2} = 0 $$</p>
<p>This is equivalent to</p>
<p>$$ T(t+\Delta t) - T(t) - \frac{D\Delta t}{\Delta x^2}(T(x+\Delta x)-2T(x)+T(x-\Delta x)) = 0 $$</p>
<p>The expression $ D\frac{\Delta t}{\Delta x^2} $ is called the diffusion number, denoted here with $s$:</p>
<p>$$ s = D\frac{\Delta t}{\Delta x^2} $$</p>
<h2 id="ftcs-explicit-scheme-and-analytic-solution">FTCS explicit scheme and analytic solution</h2>
<p>If we use $n$ to refer to indices in time and $j$ to refer to indices in space, the above equation can be written as</p>
<p>$$ T[n+1,j] = T[n,j] + s(T[n,j+1]-2T[n,j]+T[n,j-1]) $$</p>
<p>This is called a forward-in-time, centered-in-space (FTCS) scheme. Its &lsquo;footprint&rsquo; looks like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#00a">import</span> <span style="color:#0aa;text-decoration:underline">numpy</span> <span style="color:#00a">as</span> <span style="color:#0aa;text-decoration:underline">np</span>
</span></span><span style="display:flex;"><span><span style="color:#00a">import</span> <span style="color:#0aa;text-decoration:underline">matplotlib.pyplot</span> <span style="color:#00a">as</span> <span style="color:#0aa;text-decoration:underline">plt</span>
</span></span><span style="display:flex;"><span>%matplotlib inline
</span></span><span style="display:flex;"><span>%config InlineBackend.figure_format = <span style="color:#a50">&#39;svg&#39;</span> <span style="color:#aaa;font-style:italic"># display plots in SVG format</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fig = plt.figure(figsize=(<span style="color:#099">6</span>,<span style="color:#099">3</span>))
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">0</span>,<span style="color:#099">2</span>],[<span style="color:#099">0</span>,<span style="color:#099">0</span>],<span style="color:#a50">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">1</span>,<span style="color:#099">1</span>],[<span style="color:#099">0</span>,<span style="color:#099">1</span>],<span style="color:#a50">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">1</span>],[<span style="color:#099">0</span>,<span style="color:#099">0</span>,<span style="color:#099">0</span>,<span style="color:#099">1</span>],<span style="color:#a50">&#39;ko&#39;</span>,markersize=<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">1.1</span>,<span style="color:#099">0.1</span>,<span style="color:#a50">&#39;T[n,j]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">0.1</span>,<span style="color:#099">0.1</span>,<span style="color:#a50">&#39;T[n,j-1]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">1.1</span>,<span style="color:#099">1.1</span>,<span style="color:#a50">&#39;T[n+1,j]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">2.1</span>,<span style="color:#099">0.1</span>,<span style="color:#a50">&#39;T[n,j+1]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a50">&#39;space&#39;</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a50">&#39;time&#39;</span>)
</span></span><span style="display:flex;"><span>plt.axis(<span style="color:#a50">&#39;equal&#39;</span>)
</span></span><span style="display:flex;"><span>plt.yticks([<span style="color:#099">0.0</span>,<span style="color:#099">1.0</span>],[])
</span></span><span style="display:flex;"><span>plt.xticks([<span style="color:#099">0.0</span>,<span style="color:#099">1.0</span>],[])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a50">&#39;FTCS explicit scheme&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.axis([-<span style="color:#099">0.5</span>,<span style="color:#099">2.5</span>,-<span style="color:#099">0.5</span>,<span style="color:#099">1.5</span>]);
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_1.png#center600"></p>
<p>Now we are ready to write the code that is the solution for exercise 2 in Chapter 2 of Slingerland and Kump (2011). This is an example where the one-dimensional diffusion equation is applied to viscous flow of a Newtonian fluid adjacent to a solid wall. If the wall starts moving with a velocity of 10 m/s, and the flow is assumed to be laminar, the velocity profile of the fluid is described by the equation</p>
<p>$$ \frac{\partial V}{\partial t} - \nu \frac{\partial^2 V}{\partial y^2} = 0 $$</p>
<p>where $\nu$ is the kinematic viscosity of the fluid. We want to figure out how the velocity will change through time as a function of distance from the wall. [Note that I have changed the original 40 m/s to 10 m/s &ndash; the former seems like an unnaturally large velocity to me].</p>
<p>We can compare the numerical results with the analytic solution, which is known for this problem:</p>
<p>$$ V = V_0 \Big( \sum\limits_0^\infty erfc(2n\eta_1+\eta) - \sum\limits_0^\infty erfc(2(n+1)\eta_1+\eta) \Big)  $$</p>
<p>where</p>
<p>$$ \eta_1 = \frac{h}{2\sqrt{\nu t}} $$</p>
<p>and</p>
<p>$$ \eta = \frac{y}{2\sqrt{\nu t}} $$</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>dt = <span style="color:#099">0.0005</span> <span style="color:#aaa;font-style:italic"># grid size for time (s)</span>
</span></span><span style="display:flex;"><span>dy = <span style="color:#099">0.0005</span> <span style="color:#aaa;font-style:italic"># grid size for space (m)</span>
</span></span><span style="display:flex;"><span>viscosity = <span style="color:#099">2</span>*<span style="color:#099">10</span>**(-<span style="color:#099">4</span>) <span style="color:#aaa;font-style:italic"># kinematic viscosity of oil (m2/s)</span>
</span></span><span style="display:flex;"><span>y_max = <span style="color:#099">0.04</span> <span style="color:#aaa;font-style:italic"># in m</span>
</span></span><span style="display:flex;"><span>t_max = <span style="color:#099">1</span> <span style="color:#aaa;font-style:italic"># total time in s</span>
</span></span><span style="display:flex;"><span>V0 = <span style="color:#099">10</span> <span style="color:#aaa;font-style:italic"># velocity in m/s</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#aaa;font-style:italic"># function to calculate velocity profiles based on a finite difference approximation to the 1D diffusion equation and the</span>
</span></span><span style="display:flex;"><span><span style="color:#aaa;font-style:italic"># FTCS (forward-in-time, centered-in-space) scheme:</span>
</span></span><span style="display:flex;"><span><span style="color:#00a">def</span> <span style="color:#0a0">diffusion_FTCS</span>(dt,dy,t_max,y_max,viscosity,V0):
</span></span><span style="display:flex;"><span><span style="color:#aaa;font-style:italic"># diffusion number (has to be less than 0.5 for the solution to be stable):</span>
</span></span><span style="display:flex;"><span>s = viscosity*dt/dy**<span style="color:#099">2</span>
</span></span><span style="display:flex;"><span>y = np.arange(<span style="color:#099">0</span>,y_max+dy,dy)
</span></span><span style="display:flex;"><span>t = np.arange(<span style="color:#099">0</span>,t_max+dt,dt)
</span></span><span style="display:flex;"><span>r = <span style="color:#0aa">len</span>(t)
</span></span><span style="display:flex;"><span>c = <span style="color:#0aa">len</span>(y)
</span></span><span style="display:flex;"><span>V = np.zeros([r,c])
</span></span><span style="display:flex;"><span>V[:,<span style="color:#099">0</span>] = V0
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> n <span style="color:#00a">in</span> <span style="color:#0aa">range</span>(<span style="color:#099">0</span>,r-<span style="color:#099">1</span>): <span style="color:#aaa;font-style:italic"># time</span>
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> j <span style="color:#00a">in</span> <span style="color:#0aa">range</span>(<span style="color:#099">1</span>,c-<span style="color:#099">1</span>): <span style="color:#aaa;font-style:italic"># space</span>
</span></span><span style="display:flex;"><span>V[n+<span style="color:#099">1</span>,j] = V[n,j] + s*(V[n,j-<span style="color:#099">1</span>] - <span style="color:#099">2</span>*V[n,j] + V[n,j+<span style="color:#099">1</span>])
</span></span><span style="display:flex;"><span><span style="color:#00a">return</span> y,V,r,s
</span></span><span style="display:flex;"><span><span style="color:#aaa;font-style:italic"># note that this can be written without the for-loop in space, but it is easier to read it this way</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00a">from</span> <span style="color:#0aa;text-decoration:underline">scipy.special</span> <span style="color:#00a">import</span> erfc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#aaa;font-style:italic"># function to calculate velocity profiles using the analytic solution:</span>
</span></span><span style="display:flex;"><span><span style="color:#00a">def</span> <span style="color:#0a0">diffusion_analytic</span>(t,h,V0,dy,viscosity):
</span></span><span style="display:flex;"><span>y = np.arange(<span style="color:#099">0</span>,h+dy,dy)
</span></span><span style="display:flex;"><span>eta1 = h/(<span style="color:#099">2</span>*(t*viscosity)**<span style="color:#099">0.5</span>)
</span></span><span style="display:flex;"><span>eta = y/(<span style="color:#099">2</span>*(t*viscosity)**<span style="color:#099">0.5</span>)
</span></span><span style="display:flex;"><span>sum1 = <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>sum2 = <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> n <span style="color:#00a">in</span> <span style="color:#0aa">range</span>(<span style="color:#099">0</span>,<span style="color:#099">1000</span>):
</span></span><span style="display:flex;"><span>sum1 = sum1 + erfc(<span style="color:#099">2</span>*n*eta1+eta)
</span></span><span style="display:flex;"><span>sum2 = sum2 + erfc(<span style="color:#099">2</span>*(n+<span style="color:#099">1</span>)*eta1-eta)
</span></span><span style="display:flex;"><span>V_analytic = V0*(sum1-sum2)
</span></span><span style="display:flex;"><span><span style="color:#00a">return</span> V_analytic
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>y,V,r,s = diffusion_FTCS(dt,dy,t_max,y_max,viscosity,V0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#aaa;font-style:italic"># plotting:</span>
</span></span><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#099">7</span>,<span style="color:#099">5</span>))
</span></span><span style="display:flex;"><span>plot_times = np.arange(<span style="color:#099">0.2</span>,<span style="color:#099">1.0</span>,<span style="color:#099">0.1</span>)
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> t <span style="color:#00a">in</span> plot_times:
</span></span><span style="display:flex;"><span>plt.plot(y,V[t/dt,:],<span style="color:#a50">&#39;Gray&#39;</span>,label=<span style="color:#a50">&#39;numerical&#39;</span>)
</span></span><span style="display:flex;"><span>V_analytic = diffusion_analytic(t,<span style="color:#099">0.04</span>,<span style="color:#099">10</span>,dy,viscosity)
</span></span><span style="display:flex;"><span>plt.plot(y,V_analytic,<span style="color:#a50">&#39;ok&#39;</span>,label=<span style="color:#a50">&#39;analytic&#39;</span>,markersize=<span style="color:#099">3</span>)
</span></span><span style="display:flex;"><span><span style="color:#00a">if</span> t==<span style="color:#099">0.2</span>:
</span></span><span style="display:flex;"><span>plt.legend(fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a50">&#39;distance from wall (m)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a50">&#39;velocity (m/s)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.axis([<span style="color:#099">0</span>,y_max,<span style="color:#099">0</span>,V0])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a50">&#39;comparison between explicit numerical </span><span style="color:#a50">\n</span><span style="color:#a50">(FTCS scheme) and analytic solutions&#39;</span>);
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_2.png#center600"></p>
<p>The dots (analytic solution) overlap pretty well with the lines (numerical solution). However, this would not be the case if we changed the discretization so that the diffusion number was larger. Let&rsquo;s look at the stability of the FTCS numerical scheme, by computing the solution with different diffusion numbers. It turns out that the diffusion number $s$ has to be less than 0.5 for the FTCS scheme to remain stable. What follows is a reproduction of Figure 2.7 in Slingerland and Kump (2011):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>dt = <span style="color:#099">0.0005</span> <span style="color:#aaa;font-style:italic"># grid size for time (m)</span>
</span></span><span style="display:flex;"><span>dy = <span style="color:#099">0.0005</span> <span style="color:#aaa;font-style:italic"># grid size for space (s)</span>
</span></span><span style="display:flex;"><span>y,V,r,s = diffusion_FTCS(dt,dy,t_max,y_max,viscosity,V0)
</span></span><span style="display:flex;"><span>V_analytic = diffusion_analytic(<span style="color:#099">0.5</span>,<span style="color:#099">0.04</span>,V0,dy,viscosity)
</span></span><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#099">7</span>,<span style="color:#099">5</span>))
</span></span><span style="display:flex;"><span>plt.plot(y,V_analytic-V[<span style="color:#0aa">int</span>(<span style="color:#099">0.5</span>/dt)],<span style="color:#a50">&#39;--k&#39;</span>,label=<span style="color:#a50">&#39;small s&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dy = <span style="color:#099">0.0010</span>
</span></span><span style="display:flex;"><span>dt = <span style="color:#099">0.00254</span>
</span></span><span style="display:flex;"><span>y,V,r,s = diffusion_FTCS(dt,dy,t_max,y_max,viscosity,V0)
</span></span><span style="display:flex;"><span>V_analytic = diffusion_analytic(<span style="color:#099">0.5</span>,<span style="color:#099">0.04</span>,V0,dy,viscosity)
</span></span><span style="display:flex;"><span>V_numeric = V[<span style="color:#0aa">int</span>(r/<span style="color:#099">2</span>-<span style="color:#099">1</span>),:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.plot(y,V_analytic-V_numeric,<span style="color:#a50">&#39;k&#39;</span>,label=<span style="color:#a50">&#39;large s&#39;</span>)
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a50">&#39;distance from wall (m)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a50">&#39;velocity difference (m/s)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a50">&#39;difference between numerical and analytic </span><span style="color:#a50">\n</span><span style="color:#a50"> solutions for different </span><span style="color:#a50">\&#39;</span><span style="color:#a50">s</span><span style="color:#a50">\&#39;</span><span style="color:#a50"> values&#39;</span>,fontsize=<span style="color:#099">14</span>)
</span></span><span style="display:flex;"><span>plt.axis([<span style="color:#099">0</span>,y_max,-<span style="color:#099">4</span>,<span style="color:#099">4</span>])
</span></span><span style="display:flex;"><span>plt.legend();
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_3.png#center600"></p>
<h2 id="laasonen-implicit-scheme">Laasonen implicit scheme</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#099">6</span>,<span style="color:#099">3</span>))
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">0</span>,<span style="color:#099">2</span>],[<span style="color:#099">1</span>,<span style="color:#099">1</span>],<span style="color:#a50">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">1</span>,<span style="color:#099">1</span>],[<span style="color:#099">0</span>,<span style="color:#099">1</span>],<span style="color:#a50">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">1</span>],[<span style="color:#099">1</span>,<span style="color:#099">1</span>,<span style="color:#099">1</span>,<span style="color:#099">0</span>],<span style="color:#a50">&#39;ko&#39;</span>,markersize=<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">1.1</span>,<span style="color:#099">0.1</span>,<span style="color:#a50">&#39;T[n,j]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">0.1</span>,<span style="color:#099">1.1</span>,<span style="color:#a50">&#39;T[n+1,j-1]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">1.1</span>,<span style="color:#099">1.1</span>,<span style="color:#a50">&#39;T[n+1,j]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">2.1</span>,<span style="color:#099">1.1</span>,<span style="color:#a50">&#39;T[n+1,j+1]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a50">&#39;space&#39;</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a50">&#39;time&#39;</span>)
</span></span><span style="display:flex;"><span>plt.axis(<span style="color:#a50">&#39;equal&#39;</span>)
</span></span><span style="display:flex;"><span>plt.yticks([<span style="color:#099">0.0</span>,<span style="color:#099">1.0</span>],[])
</span></span><span style="display:flex;"><span>plt.xticks([<span style="color:#099">0.0</span>,<span style="color:#099">1.0</span>],[])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a50">&#39;Laasonen scheme&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.axis([-<span style="color:#099">0.5</span>,<span style="color:#099">2.5</span>,-<span style="color:#099">0.5</span>,<span style="color:#099">1.5</span>]);
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_4.png#center600"></p>
<p>Instead of estimating the velocity at time step $n+1$ with the curvature calculated at time step $n$, as it is done in the FTCS explicit scheme, we can also estimate the curvature at time step $n+1$, using the velocity change from time step $n$ to time step $n+1$:</p>
<p>$$ s\big(T(x+\Delta x)-2T(x)+T(x-\Delta x)\big) = T(t+\Delta t)-T(t) $$</p>
<p>Written in matrix notation, this is equiavlent to</p>
<p>$$ s\big(T[n+1,j+1]-2T[n+1,j]+T[n+1,j-1]\big) = T[n+1,j]-T[n,j] $$</p>
<p>After some reshuffling we get</p>
<p>$$ -sT[n+1,j+1] + (1+2s)T[n+1,j] - sT[n+1,j-1] = T[n,j] $$</p>
<p>This is the Laasonen fully implicit scheme. Unlike the FTCS scheme, the Laasonen scheme is unconditionally stable. Let&rsquo;s try to write some Python code that implements this scheme. First it is useful for me to go through the logic of constructing the system of equations that needs to be solved. Let&rsquo;s consider a grid that only consists of 5 nodes in space and we are going to estimate the values of $T$ at the locations marked by the red dots in the figure below. Black dots mark the locations where we already know the values of $T$ (from the initial and boundary conditions).</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#099">6</span>,<span style="color:#099">3</span>))
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">0</span>,<span style="color:#099">4</span>,<span style="color:#099">4</span>,<span style="color:#099">0</span>],[<span style="color:#099">0</span>,<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">1</span>],<span style="color:#a50">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> i <span style="color:#00a">in</span> <span style="color:#0aa">range</span>(<span style="color:#099">0</span>,<span style="color:#099">4</span>):
</span></span><span style="display:flex;"><span>plt.plot([i,i],[<span style="color:#099">0</span>,<span style="color:#099">1</span>],<span style="color:#a50">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">0</span>,<span style="color:#099">4</span>],[<span style="color:#099">0</span>,<span style="color:#099">0</span>,<span style="color:#099">0</span>,<span style="color:#099">0</span>,<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">1</span>],<span style="color:#a50">&#39;ko&#39;</span>,markersize=<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>],[<span style="color:#099">1</span>,<span style="color:#099">1</span>,<span style="color:#099">1</span>],<span style="color:#a50">&#39;ro&#39;</span>,markersize=<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> i <span style="color:#00a">in</span> <span style="color:#0aa">range</span>(<span style="color:#099">0</span>,<span style="color:#099">5</span>):
</span></span><span style="display:flex;"><span>plt.text(i+<span style="color:#099">0.1</span>,<span style="color:#099">0.1</span>,<span style="color:#a50">&#39;T[0,&#39;</span>+<span style="color:#0aa">str</span>(i)+<span style="color:#a50">&#39;]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.text(i+<span style="color:#099">0.1</span>,<span style="color:#099">1.1</span>,<span style="color:#a50">&#39;T[1,&#39;</span>+<span style="color:#0aa">str</span>(i)+<span style="color:#a50">&#39;]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a50">&#39;space&#39;</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a50">&#39;time&#39;</span>)
</span></span><span style="display:flex;"><span>plt.axis(<span style="color:#a50">&#39;equal&#39;</span>)
</span></span><span style="display:flex;"><span>plt.yticks([<span style="color:#099">0.0</span>,<span style="color:#099">1.0</span>],[<span style="color:#a50">&#39;0&#39;</span>,<span style="color:#a50">&#39;1&#39;</span>])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a50">&#39;first two time steps on a 1D grid of five points&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.axis([-<span style="color:#099">0.5</span>,<span style="color:#099">4.8</span>,-<span style="color:#099">0.5</span>,<span style="color:#099">1.5</span>]);
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_5.png#center600"></p>
<p>First we write the equations using the Laasonen scheme centered on the three points of unknown velocity (or temperature) &ndash; these are the red dots in the figure above:</p>
<p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_6.png#center800"></p>
<p>It may seem like we have five unknowns and only three equations but $T[1,0]$ and $T[1,4]$ are on the boundaries and they are known. Let&rsquo;s rearrange the equation system so that the left hand side has ony the unknowns:</p>
<p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_7.png#center700"></p>
<p>In matrix form this is equivalent to</p>
<p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_8.png#center600"></p>
<p>This of course can be extended to larger dimensions than shown here.
Now we are ready to write the code for the Laasonen scheme. One important difference relative to what I did in the explicit scheme example is that in this case we only keep the last two versions of the velocity distribution in memory, as opposed to preallocating the full array of $nt \times ny$ size as we did before. This difference is not a significant time saver for simple problems like this but once you start dealing with more complicated tasks and code it is not possible and/or practical to keep the results of all time steps in memory.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#00a">from</span> <span style="color:#0aa;text-decoration:underline">scipy.sparse</span> <span style="color:#00a">import</span> diags
</span></span><span style="display:flex;"><span><span style="color:#00a">def</span> <span style="color:#0a0">diffusion_Laasonen</span>(dt,dy,t_max,y_max,viscosity,V0,V1):
</span></span><span style="display:flex;"><span>s = viscosity*dt/dy**<span style="color:#099">2</span>  <span style="color:#aaa;font-style:italic"># diffusion number</span>
</span></span><span style="display:flex;"><span>y = np.arange(<span style="color:#099">0</span>,y_max+dy,dy)
</span></span><span style="display:flex;"><span>t = np.arange(<span style="color:#099">0</span>,t_max+dt,dt)
</span></span><span style="display:flex;"><span>nt = <span style="color:#0aa">len</span>(t) <span style="color:#aaa;font-style:italic"># number of time steps</span>
</span></span><span style="display:flex;"><span>ny = <span style="color:#0aa">len</span>(y) <span style="color:#aaa;font-style:italic"># number of dy steps</span>
</span></span><span style="display:flex;"><span>V = np.zeros((ny,)) <span style="color:#aaa;font-style:italic"># initial condition</span>
</span></span><span style="display:flex;"><span>V[<span style="color:#099">0</span>] = V0 <span style="color:#aaa;font-style:italic"># boundary condition on left side</span>
</span></span><span style="display:flex;"><span>V[-<span style="color:#099">1</span>] = V1 <span style="color:#aaa;font-style:italic"># boundary condition on right side</span>
</span></span><span style="display:flex;"><span>A = diags([-s, <span style="color:#099">1</span>+<span style="color:#099">2</span>*s, -s], [-<span style="color:#099">1</span>, <span style="color:#099">0</span>, <span style="color:#099">1</span>], shape=(ny-<span style="color:#099">2</span>, ny-<span style="color:#099">2</span>)).toarray() <span style="color:#aaa;font-style:italic"># create coefficient matrix</span>
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> n <span style="color:#00a">in</span> <span style="color:#0aa">range</span>(nt): <span style="color:#aaa;font-style:italic"># time is going from second time step to last</span>
</span></span><span style="display:flex;"><span>Vn = V <span style="color:#aaa;font-style:italic">#.copy()</span>
</span></span><span style="display:flex;"><span>B = Vn[<span style="color:#099">1</span>:-<span style="color:#099">1</span>] <span style="color:#aaa;font-style:italic"># create matrix of knowns on the RHS of the equation</span>
</span></span><span style="display:flex;"><span>B[<span style="color:#099">0</span>] = B[<span style="color:#099">0</span>]+s*V0
</span></span><span style="display:flex;"><span>B[-<span style="color:#099">1</span>] = B[-<span style="color:#099">1</span>]+s*V1
</span></span><span style="display:flex;"><span>V[<span style="color:#099">1</span>:-<span style="color:#099">1</span>] = np.linalg.solve(A,B) <span style="color:#aaa;font-style:italic"># solve the equation using numpy</span>
</span></span><span style="display:flex;"><span><span style="color:#00a">return</span> y,t,V,s
</span></span></code></pre></div><p>Because this is a stable scheme, it is possible to get reasonable solutions with relatively large time steps (which was not possible with the FTCS scheme):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>dt = <span style="color:#099">0.01</span> <span style="color:#aaa;font-style:italic"># grid size for time (s)</span>
</span></span><span style="display:flex;"><span>dy = <span style="color:#099">0.0005</span> <span style="color:#aaa;font-style:italic"># grid size for space (m)</span>
</span></span><span style="display:flex;"><span>viscosity = <span style="color:#099">2</span>*<span style="color:#099">10</span>**(-<span style="color:#099">4</span>) <span style="color:#aaa;font-style:italic"># kinematic viscosity of oil (m2/s)</span>
</span></span><span style="display:flex;"><span>y_max = <span style="color:#099">0.04</span> <span style="color:#aaa;font-style:italic"># in m</span>
</span></span><span style="display:flex;"><span>V0 = <span style="color:#099">10.0</span> <span style="color:#aaa;font-style:italic"># velocity in m/s</span>
</span></span><span style="display:flex;"><span>V1 = <span style="color:#099">0.0</span> <span style="color:#aaa;font-style:italic"># velocity in m/s</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#099">7</span>,<span style="color:#099">5</span>))
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> time <span style="color:#00a">in</span> np.linspace(<span style="color:#099">0</span>,<span style="color:#099">1.0</span>,<span style="color:#099">10</span>):
</span></span><span style="display:flex;"><span>y,t,V,s = diffusion_Laasonen(dt,dy,time,y_max,viscosity,V0,V1)
</span></span><span style="display:flex;"><span>plt.plot(y,V,<span style="color:#a50">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a50">&#39;distance from wall (m)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a50">&#39;velocity (m/s)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.axis([<span style="color:#099">0</span>,y_max,<span style="color:#099">0</span>,V0])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a50">&#39;Laasonen implicit scheme&#39;</span>,fontsize=<span style="color:#099">14</span>);
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_9.png#center600"></p>
<p>Just for fun, let&rsquo;s see what happens if we set in motion the right side of the domain as well; that is, set $V_1$ to a non-zero value:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>dt = <span style="color:#099">0.01</span> <span style="color:#aaa;font-style:italic"># grid size for time (s)</span>
</span></span><span style="display:flex;"><span>dy = <span style="color:#099">0.0005</span> <span style="color:#aaa;font-style:italic"># grid size for space (m)</span>
</span></span><span style="display:flex;"><span>viscosity = <span style="color:#099">2</span>*<span style="color:#099">10</span>**(-<span style="color:#099">4</span>) <span style="color:#aaa;font-style:italic"># kinematic viscosity of oil (m2/s)</span>
</span></span><span style="display:flex;"><span>y_max = <span style="color:#099">0.04</span> <span style="color:#aaa;font-style:italic"># in m</span>
</span></span><span style="display:flex;"><span>V0 = <span style="color:#099">10.0</span> <span style="color:#aaa;font-style:italic"># velocity in m/s</span>
</span></span><span style="display:flex;"><span>V1 = <span style="color:#099">5.0</span> <span style="color:#aaa;font-style:italic"># velocity in m/s</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#099">7</span>,<span style="color:#099">5</span>))
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> time <span style="color:#00a">in</span> np.linspace(<span style="color:#099">0</span>,<span style="color:#099">1.0</span>,<span style="color:#099">10</span>):
</span></span><span style="display:flex;"><span>y,t,V,s = diffusion_Laasonen(dt,dy,time,y_max,viscosity,V0,V1)
</span></span><span style="display:flex;"><span>plt.plot(y,V,<span style="color:#a50">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a50">&#39;distance from wall (m)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a50">&#39;velocity (m/s)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.axis([<span style="color:#099">0</span>,y_max,<span style="color:#099">0</span>,V0])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a50">&#39;Laasonen implicit scheme&#39;</span>,fontsize=<span style="color:#099">14</span>);
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_10.png#center600"></p>
<h2 id="crank-nicolson-scheme">Crank-Nicolson scheme</h2>
<p>The Crank-Nicholson scheme is based on the idea that the forward-in-time approximation of the time derivative is estimating the derivative at the halfway point between times $n$ and $n+1$, therefore the curvature of space should be estimated there as well. The &lsquo;footprint&rsquo; of the scheme looks like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#099">6</span>,<span style="color:#099">3</span>))
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">0</span>,<span style="color:#099">2</span>],[<span style="color:#099">0</span>,<span style="color:#099">0</span>],<span style="color:#a50">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">0</span>,<span style="color:#099">2</span>],[<span style="color:#099">1</span>,<span style="color:#099">1</span>],<span style="color:#a50">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">1</span>,<span style="color:#099">1</span>],[<span style="color:#099">0</span>,<span style="color:#099">1</span>],<span style="color:#a50">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.plot([<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">2</span>],[<span style="color:#099">0</span>,<span style="color:#099">0</span>,<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">1</span>,<span style="color:#099">1</span>],<span style="color:#a50">&#39;ko&#39;</span>,markersize=<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">0.1</span>,<span style="color:#099">0.1</span>,<span style="color:#a50">&#39;T[n,j-1]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">1.1</span>,<span style="color:#099">0.1</span>,<span style="color:#a50">&#39;T[n,j]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">2.1</span>,<span style="color:#099">0.1</span>,<span style="color:#a50">&#39;T[n,j+1]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">0.1</span>,<span style="color:#099">1.1</span>,<span style="color:#a50">&#39;T[n+1,j-1]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">1.1</span>,<span style="color:#099">1.1</span>,<span style="color:#a50">&#39;T[n+1,j]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.text(<span style="color:#099">2.1</span>,<span style="color:#099">1.1</span>,<span style="color:#a50">&#39;T[n+1,j+1]&#39;</span>)
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a50">&#39;space&#39;</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a50">&#39;time&#39;</span>)
</span></span><span style="display:flex;"><span>plt.axis(<span style="color:#a50">&#39;equal&#39;</span>)
</span></span><span style="display:flex;"><span>plt.yticks([<span style="color:#099">0.0</span>,<span style="color:#099">1.0</span>],[])
</span></span><span style="display:flex;"><span>plt.xticks([<span style="color:#099">0.0</span>,<span style="color:#099">1.0</span>],[])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a50">&#39;Crank-Nicolson scheme&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.axis([-<span style="color:#099">0.5</span>,<span style="color:#099">2.5</span>,-<span style="color:#099">0.5</span>,<span style="color:#099">1.5</span>]);
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_11.png#center600"></p>
<p>The curvature at the halfway point can be estimated through averaging the curvatures that are calculated at $n$ and $n+1$:</p>
<p>$$ 0.5s\big(T[n+1,j+1]-2T[n+1,j]+T[n+1,j-1]\big) + 0.5s\big(T[n,j+1]-2T[n,j]+T[n,j-1]\big) = T[n+1,j]-T[n,j] $$</p>
<p>This can be rearranged so that terms at $n+1$ are on the left hand side:</p>
<p>$$ -0.5sT[n+1,j-1]+(1+s)T[n+1,j]-0.5sT[n+1,j+1] = 0.5sT[n,j-1]+(1-s)T[n,j]+0.5sT[n,j+1] $$</p>
<p>Just like we did for the Laasonen scheme, we can write the equations for the first two time steps:</p>
<p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/array_1.png#center700"></p>
<p>Writing this in matrix form, with all the unknowns on the LHS:</p>
<p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/array_2.png#center700"></p>
<p>Now we can write the code for the Crank-Nicolson scheme. We will use a new input parameter called $ntout$ that determines how many time steps we want to write out to memory. This way you don&rsquo;t have to re-run the code if you want to plot multiple time steps.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#00a">def</span> <span style="color:#0a0">diffusion_Crank_Nicolson</span>(dy,ny,dt,nt,D,V,ntout):
</span></span><span style="display:flex;"><span>Vout = [] <span style="color:#aaa;font-style:italic"># list for storing V arrays at certain time steps</span>
</span></span><span style="display:flex;"><span>V0 = V[<span style="color:#099">0</span>] <span style="color:#aaa;font-style:italic"># boundary condition on left side</span>
</span></span><span style="display:flex;"><span>V1 = V[-<span style="color:#099">1</span>] <span style="color:#aaa;font-style:italic"># boundary condition on right side</span>
</span></span><span style="display:flex;"><span>s = D*dt/dy**<span style="color:#099">2</span>  <span style="color:#aaa;font-style:italic"># diffusion number</span>
</span></span><span style="display:flex;"><span>A = diags([-<span style="color:#099">0.5</span>*s, <span style="color:#099">1</span>+s, -<span style="color:#099">0.5</span>*s], [-<span style="color:#099">1</span>, <span style="color:#099">0</span>, <span style="color:#099">1</span>], shape=(ny-<span style="color:#099">2</span>, ny-<span style="color:#099">2</span>)).toarray() <span style="color:#aaa;font-style:italic"># create coefficient matrix</span>
</span></span><span style="display:flex;"><span>B1 = diags([<span style="color:#099">0.5</span>*s, <span style="color:#099">1</span>-s, <span style="color:#099">0.5</span>*s],[-<span style="color:#099">1</span>, <span style="color:#099">0</span>, <span style="color:#099">1</span>], shape=(ny-<span style="color:#099">2</span>, ny-<span style="color:#099">2</span>)).toarray()
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> n <span style="color:#00a">in</span> <span style="color:#0aa">range</span>(<span style="color:#099">1</span>,nt): <span style="color:#aaa;font-style:italic"># time is going from second time step to last</span>
</span></span><span style="display:flex;"><span>Vn = V
</span></span><span style="display:flex;"><span>B = np.dot(Vn[<span style="color:#099">1</span>:-<span style="color:#099">1</span>],B1)
</span></span><span style="display:flex;"><span>B[<span style="color:#099">0</span>] = B[<span style="color:#099">0</span>]+<span style="color:#099">0.5</span>*s*(V0+V0)
</span></span><span style="display:flex;"><span>B[-<span style="color:#099">1</span>] = B[-<span style="color:#099">1</span>]+<span style="color:#099">0.5</span>*s*(V1+V1)
</span></span><span style="display:flex;"><span>V[<span style="color:#099">1</span>:-<span style="color:#099">1</span>] = np.linalg.solve(A,B)
</span></span><span style="display:flex;"><span><span style="color:#00a">if</span> n % <span style="color:#0aa">int</span>(nt/<span style="color:#0aa">float</span>(ntout)) == <span style="color:#099">0</span> <span style="color:#00a">or</span> n==nt-<span style="color:#099">1</span>:
</span></span><span style="display:flex;"><span>Vout.append(V.copy()) <span style="color:#aaa;font-style:italic"># numpy arrays are mutable, so we need to write out a copy of V, not V itself</span>
</span></span><span style="display:flex;"><span><span style="color:#00a">return</span> Vout,s
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dt = <span style="color:#099">0.001</span> <span style="color:#aaa;font-style:italic"># grid size for time (s)</span>
</span></span><span style="display:flex;"><span>dy = <span style="color:#099">0.001</span> <span style="color:#aaa;font-style:italic"># grid size for space (m)</span>
</span></span><span style="display:flex;"><span>viscosity = <span style="color:#099">2</span>*<span style="color:#099">10</span>**(-<span style="color:#099">4</span>) <span style="color:#aaa;font-style:italic"># kinematic viscosity of oil (m2/s)</span>
</span></span><span style="display:flex;"><span>y_max = <span style="color:#099">0.04</span> <span style="color:#aaa;font-style:italic"># in m</span>
</span></span><span style="display:flex;"><span>y = np.arange(<span style="color:#099">0</span>,y_max+dy,dy)
</span></span><span style="display:flex;"><span>ny = <span style="color:#0aa">len</span>(y)
</span></span><span style="display:flex;"><span>nt = <span style="color:#099">1000</span>
</span></span><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#099">7</span>,<span style="color:#099">5</span>))
</span></span><span style="display:flex;"><span>V = np.zeros((ny,)) <span style="color:#aaa;font-style:italic"># initial condition</span>
</span></span><span style="display:flex;"><span>V[<span style="color:#099">0</span>] = <span style="color:#099">10</span>
</span></span><span style="display:flex;"><span>Vout,s = diffusion_Crank_Nicolson(dy,ny,dt,nt,viscosity,V,<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> V <span style="color:#00a">in</span> Vout:
</span></span><span style="display:flex;"><span>plt.plot(y,V,<span style="color:#a50">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a50">&#39;distance from wall (m)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a50">&#39;velocity (m/s)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.axis([<span style="color:#099">0</span>,y_max,<span style="color:#099">0</span>,V[<span style="color:#099">0</span>]])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a50">&#39;Crank-Nicolson scheme&#39;</span>,fontsize=<span style="color:#099">14</span>);
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_12.png#center600"></p>
<h2 id="fault-scarp-diffusion">Fault scarp diffusion</h2>
<p>So far we have been using a somewhat artificial (but simple) example to explore numerical methods that can be used to solve the diffusion equation. Next we look at a geomorphologic application: the evolution of a fault scarp through time. Although the idea that convex hillslopes are the result of diffusive processes go back to G. K. Gilbert, it was Culling (1960, in the paper <a href="http://www.jstor.org/stable/30059222" target="_blank">Analytical Theory of Erosion</a>) who first applied the mathematics of the heat equation - that was already well known to physicists at that time - to geomorphology.</p>
<p>Here I used the Crank-Nicolson scheme to model a fault scarp with a vertical offset of 10 m. To compare the numerical results with the analytical solution (which comes from Culling, 1960), I created a function that was written using a Python package for symbolic math called <a href="http://sympy.org" target="_blank">sympy</a>. One of the advantages of sympy is that you can quickly display equations in $\LaTeX$.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#00a">import</span> <span style="color:#0aa;text-decoration:underline">sympy</span>
</span></span><span style="display:flex;"><span><span style="color:#00a">from</span> <span style="color:#0aa;text-decoration:underline">sympy</span> <span style="color:#00a">import</span> init_printing
</span></span><span style="display:flex;"><span>init_printing(use_latex=<span style="color:#00a">True</span>)
</span></span><span style="display:flex;"><span>x, t, Y1, a, K = sympy.symbols(<span style="color:#a50">&#39;x t Y1 a K&#39;</span>)
</span></span><span style="display:flex;"><span>Y = (<span style="color:#099">1</span>/<span style="color:#099">2.0</span>)*Y1*(sympy.erf((a-x)/(<span style="color:#099">2</span>*sympy.sqrt(K*t))) + sympy.erf((a+x)/(<span style="color:#099">2</span>*sympy.sqrt(K*t))))
</span></span><span style="display:flex;"><span>Y
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/eq_1.png#center400"></p>
<p>The variables in this equation are $x$ - horizontal coordinates, $t$ - time, $a$ - value of $x$ where fault is located, $K$ - diffusion coefficient, $Y_1$ - height of fault scarp.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#00a">from</span> <span style="color:#0aa;text-decoration:underline">sympy.utilities.lambdify</span> <span style="color:#00a">import</span> lambdify
</span></span><span style="display:flex;"><span>f = lambdify((x, t, Y1, a, K), Y, modules=[<span style="color:#a50">&#39;numpy&#39;</span>, <span style="color:#a50">&#39;sympy&#39;</span>]) <span style="color:#aaa;font-style:italic"># function for analytic solution</span>
</span></span><span style="display:flex;"><span>dt = <span style="color:#099">2.5</span> <span style="color:#aaa;font-style:italic"># time step (years)</span>
</span></span><span style="display:flex;"><span>dy = <span style="color:#099">0.1</span> <span style="color:#aaa;font-style:italic"># grid size for space (m)</span>
</span></span><span style="display:flex;"><span>D = <span style="color:#099">50E-4</span> <span style="color:#aaa;font-style:italic"># diffusion coefficient in m2/yr - e.g., Fernandes and Dietrich, 1997</span>
</span></span><span style="display:flex;"><span>h = <span style="color:#099">10</span> <span style="color:#aaa;font-style:italic"># height of fault scarp in m</span>
</span></span><span style="display:flex;"><span>y_max = <span style="color:#099">20</span> <span style="color:#aaa;font-style:italic"># length of domain in m</span>
</span></span><span style="display:flex;"><span>t_max = <span style="color:#099">500</span> <span style="color:#aaa;font-style:italic"># total time in years</span>
</span></span><span style="display:flex;"><span>y = np.arange(<span style="color:#099">0</span>,y_max+dy,dy)
</span></span><span style="display:flex;"><span>ny = <span style="color:#0aa">len</span>(y)
</span></span><span style="display:flex;"><span>nt = <span style="color:#0aa">int</span>(t_max/dt)
</span></span><span style="display:flex;"><span>V = np.zeros((ny,)) <span style="color:#aaa;font-style:italic"># initial condition</span>
</span></span><span style="display:flex;"><span>V[:<span style="color:#0aa">round</span>(ny/<span style="color:#099">2.0</span>)] = h <span style="color:#aaa;font-style:italic"># initial condition</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Vout,s = diffusion_Crank_Nicolson(dy,ny,dt,nt,D,V,<span style="color:#099">20</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#099">10</span>,<span style="color:#099">5.2</span>))
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> V <span style="color:#00a">in</span> Vout:
</span></span><span style="display:flex;"><span>plt.plot(y,V,<span style="color:#a50">&#39;gray&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a50">&#39;distance (m)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a50">&#39;height (m)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.axis([<span style="color:#099">0</span>,y_max,<span style="color:#099">0</span>,<span style="color:#099">10</span>])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a50">&#39;fault scarp diffusion&#39;</span>,fontsize=<span style="color:#099">14</span>);
</span></span><span style="display:flex;"><span>plt.plot(y,np.asarray([f(x0, t_max, h, y_max/<span style="color:#099">2.0</span>, D) <span style="color:#00a">for</span> x0 <span style="color:#00a">in</span> y]),<span style="color:#a50">&#39;r--&#39;</span>,linewidth=<span style="color:#099">2</span>);
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_13.png#center800"></p>
<p>The numerical and analytic solutions (dashed red line) are very similar in this case (total time = 500 years). Let&rsquo;s see what happens if we let the fault scarp evolve for a longer time.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>dt = <span style="color:#099">2.5</span> <span style="color:#aaa;font-style:italic"># time step (years)</span>
</span></span><span style="display:flex;"><span>dy = <span style="color:#099">0.1</span> <span style="color:#aaa;font-style:italic"># grid size for space (m)</span>
</span></span><span style="display:flex;"><span>D = <span style="color:#099">50E-4</span> <span style="color:#aaa;font-style:italic"># diffusion coefficient in m2/yr - e.g., Fernandes and Dietrich, 1997</span>
</span></span><span style="display:flex;"><span>h = <span style="color:#099">10</span> <span style="color:#aaa;font-style:italic"># height of fault scarp in m</span>
</span></span><span style="display:flex;"><span>y_max = <span style="color:#099">20</span> <span style="color:#aaa;font-style:italic"># length of domain in m</span>
</span></span><span style="display:flex;"><span>t_max = <span style="color:#099">5000</span> <span style="color:#aaa;font-style:italic"># total time in years</span>
</span></span><span style="display:flex;"><span>y = np.arange(<span style="color:#099">0</span>,y_max+dy,dy)
</span></span><span style="display:flex;"><span>ny = <span style="color:#0aa">len</span>(y)
</span></span><span style="display:flex;"><span>nt = <span style="color:#0aa">int</span>(t_max/dt)
</span></span><span style="display:flex;"><span>V = np.zeros((ny,)) <span style="color:#aaa;font-style:italic"># initial condition</span>
</span></span><span style="display:flex;"><span>V[:<span style="color:#0aa">round</span>(ny/<span style="color:#099">2.0</span>)] = h <span style="color:#aaa;font-style:italic"># initial condition</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Vout,s = diffusion_Crank_Nicolson(dy,ny,dt,nt,D,V,<span style="color:#099">20</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#099">10</span>,<span style="color:#099">5.2</span>))
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> V <span style="color:#00a">in</span> Vout:
</span></span><span style="display:flex;"><span>plt.plot(y,V,<span style="color:#a50">&#39;gray&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a50">&#39;distance (m)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a50">&#39;height (m)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.axis([<span style="color:#099">0</span>,y_max,<span style="color:#099">0</span>,<span style="color:#099">10</span>])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a50">&#39;fault scarp diffusion&#39;</span>,fontsize=<span style="color:#099">14</span>);
</span></span><span style="display:flex;"><span>plt.plot(y,np.asarray([f(x0, t_max, h, y_max/<span style="color:#099">2.0</span>, D) <span style="color:#00a">for</span> x0 <span style="color:#00a">in</span> y]),<span style="color:#a50">&#39;r--&#39;</span>,linewidth=<span style="color:#099">2</span>);
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_14.png#center800"></p>
<p>This doesn&rsquo;t look very good, does it? The reason for the significant mismatch between the numerical and analytic solutions is the fixed nature of the boundary conditions: we keep the elevation at 10 m on the left side and at 0 m on the right side of the domain. There are two ways of getting a correct numerical solution: we either impose boundary conditions that approximate what the system is supposed to do if the elevations were not fixed; or we extend the space domain so that the boundary conditions can be kept fixed throughout the time of interest. Let&rsquo;s do the latter; all the other parameters are the same as above.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>dt = <span style="color:#099">2.5</span> <span style="color:#aaa;font-style:italic"># time step (years)</span>
</span></span><span style="display:flex;"><span>dy = <span style="color:#099">0.1</span> <span style="color:#aaa;font-style:italic"># grid size for space (m)</span>
</span></span><span style="display:flex;"><span>D = <span style="color:#099">50E-4</span> <span style="color:#aaa;font-style:italic"># diffusion coefficient in m2/yr - e.g., Fernandes and Dietrich, 1997</span>
</span></span><span style="display:flex;"><span>h = <span style="color:#099">10</span> <span style="color:#aaa;font-style:italic"># height of fault scarp in m</span>
</span></span><span style="display:flex;"><span>y_max = <span style="color:#099">40</span> <span style="color:#aaa;font-style:italic"># length of domain in m</span>
</span></span><span style="display:flex;"><span>t_max = <span style="color:#099">5000</span> <span style="color:#aaa;font-style:italic"># total time in years</span>
</span></span><span style="display:flex;"><span>y = np.arange(<span style="color:#099">0</span>,y_max+dy,dy)
</span></span><span style="display:flex;"><span>ny = <span style="color:#0aa">len</span>(y)
</span></span><span style="display:flex;"><span>nt = <span style="color:#0aa">int</span>(t_max/dt)
</span></span><span style="display:flex;"><span>V = np.zeros((ny,)) <span style="color:#aaa;font-style:italic"># initial condition</span>
</span></span><span style="display:flex;"><span>V[:<span style="color:#0aa">round</span>(ny/<span style="color:#099">2.0</span>)] = h <span style="color:#aaa;font-style:italic"># initial condition</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Vout,s = diffusion_Crank_Nicolson(dy,ny,dt,nt,D,V,<span style="color:#099">20</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#099">10</span>,<span style="color:#099">5.2</span>))
</span></span><span style="display:flex;"><span><span style="color:#00a">for</span> V <span style="color:#00a">in</span> Vout:
</span></span><span style="display:flex;"><span>plt.plot(y,V,<span style="color:#a50">&#39;gray&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#a50">&#39;distance (m)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.ylabel(<span style="color:#a50">&#39;height (m)&#39;</span>,fontsize=<span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>plt.axis([<span style="color:#099">0</span>,y_max,<span style="color:#099">0</span>,<span style="color:#099">10</span>])
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#a50">&#39;fault scarp diffusion&#39;</span>,fontsize=<span style="color:#099">14</span>);
</span></span><span style="display:flex;"><span>plt.plot(y,np.asarray([f(x0, t_max, h, y_max/<span style="color:#099">2.0</span>, D) <span style="color:#00a">for</span> x0 <span style="color:#00a">in</span> y]),<span style="color:#a50">&#39;r--&#39;</span>,linewidth=<span style="color:#099">2</span>);
</span></span></code></pre></div><p><img alt="drawing" loading="lazy" src="https://zsylvester.github.io/img/diffusion_fig_15.png#center800"></p>
<p>Now we have a much better result. The vertical dashed lines show the extent of the domain in the previous experiment. We have also gained some insight into choosing boundary conditions and setting up the model domain. It is not uncommon that setting up the initial and boundary conditions is the most time-consuming and difficult part of running a numerical model.</p>
<h2 id="further-reading">Further reading</h2>
<p>R. Slingerland and L. Kump (2011) <a href="http://www.amazon.com/dp/0691145148/ref=cm_sw_r_tw_dp_iG3Wub0YJKYJK" target="_blank">Mathematical Modeling of Earth&rsquo;s Dynamical Systems</a></p>
<p>W. E. H. Culling (1960) <a href="http://www.jstor.org/stable/30059222" target="_blank">Analytical Theory of Erosion</a></p>
<p>L. Barba (2013) <a href="https://github.com/barbagroup/CFDPython" target="_blank">12 steps to Navier-Stokes</a> - an excellent introduction to computational fluid dynamics that uses IPython notebooks</p>
<p>I have blogged before about the geosciency aspects of the diffusion equation over <a href="http://hinderedsettling.com/2009/11/26/hillslope-diffusion/" target="_blank">here</a>.</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://zsylvester.github.io/tags/geology/">Geology</a></li>
      <li><a href="https://zsylvester.github.io/tags/modeling/">Modeling</a></li>
      <li><a href="https://zsylvester.github.io/tags/python/">Python</a></li>
      <li><a href="https://zsylvester.github.io/tags/sedimentology/">Sedimentology</a></li>
      <li><a href="https://zsylvester.github.io/tags/erosion/">Erosion</a></li>
      <li><a href="https://zsylvester.github.io/tags/geomorphology/">Geomorphology</a></li>
      <li><a href="https://zsylvester.github.io/tags/jupyter/">Jupyter</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 Zoltán Sylvester</span> ·     
    <span>
    Powered by 
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">hugo</a>, <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">papermod</a>, &amp;
        <a href="https://github.com/pmichaillat/hugo-website/" rel="noopener" target="_blank">hugo-website</a>.
    </span>
</footer>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>
</html>
